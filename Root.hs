module Root(
            Root,
            root,
            dot,
            isZero,
            lengthSq,
            dim,
            reflect,
            rootSum,
            restrict,
            orthcomp,
            orthbasis,
            coeff
           ) where

import Data.Ratio

import Test.QuickCheck
import Control.Monad

import Data.List(intersperse,intercalate)


newtype Root = Root [Ratio Int]
    deriving (Eq,Ord)


-- |Creates a root from coefficients
root :: [Ratio Int] -> Root
--Note root always stored internally as positive
root r = Root $ positive' r


-- | Coefficients of root
coeff :: Root -> [Ratio Int]
coeff (Root r) = r


-- | Dot product of 2 roots
infixl 8 `dot`
dot :: Root -> Root -> Ratio Int
dot (Root r1) (Root r2) = sum $ zipWith (*) r1 r2

-- | Length squared of a root
lengthSq :: Root -> Ratio Int
lengthSq (Root r) = sum $ map (\x->x*x) r

-- | Sum of 2 roots as a positive root
infixl 6 `rootSum`
rootSum :: Root -> Root -> Root
rootSum r s = positive (r `add` s)

infixl 6 `add`
add :: Root -> Root -> Root
add (Root r1) (Root r2) = Root $ zipWith (+) r1 r2

infixl 7 `mul`
mul :: Ratio Int -> Root -> Root
mul s (Root r) = Root $ map (s*) r

-- | Is the current root zero
isZero :: Root -> Bool
isZero r = 0 == lengthSq r

zeros n = replicate n 0

-- | Returns a orthonormal basis of root vectors with the same span
-- | as the given roots.
orthbasis :: [Root] -> [Root]
orthbasis xs = filter (not . isZero) (orthbasis' xs)
    --Build up an orthonormal basis by gramm-smitt
    where orthbasis' xs = foldr (\x ys->red x ys:ys) [] xs
          --Reduce the respective root by each current orthogonal basis vector
          red z zs = foldr reduce' z zs

--Reduce root by taking the component orthonormal to the plane
reduce' plane root = scale `mul` root
    where scale = (plane `dot` root) / lengthSq plane

--Restrict root taking compoent tangent to plane
restrict' plane root = positive $ root `add` (scale `mul` plane)
    where scale = - (plane `dot` root) / lengthSq plane

-- | Returns the othogonal compement of the given root vector space
-- | in its ambient space
orthcomp :: [Root] -> [Root]
orthcomp rs = filter ((not . isZero)) rBasis
    where rBasis = map (restrict rs) basis
          -- Reduce each basis element 
          basis = map root $ [zeros (i-1) ++ [1] ++ zeros (dim - i) | i<-[1..dim]]
          dim = length $ coeff $ head rs

-- | Restrict the given root to the vector space spanned by the first
restrict :: [Root] -> Root -> Root
restrict res r = foldr1 add resBasis
    --Restrict r to a orthogonal basis of res and sum 
    where resBasis = map (\x->x `dot` r `mul` x) basis
          basis = orthbasis res

-- | Reflect the second root in the hyperplane generated by the first
reflect :: Root -> Root -> Root
reflect plane root = positive $ root `add` (scale `mul` plane)
    where scale = - 2 * (plane `dot` root) / lengthSq plane

-- | Dimension of ambient space of root
dim :: Root -> Int
dim (Root r) = length r

positive' :: [Ratio Int] -> [Ratio Int]
positive' [] = []
positive' (r:rs)
    | r > 0 = r:rs
    | r < 0 = map ((-1)*) (r:rs)
    | otherwise = 0: positive' rs


--Returns the root with coeefficients postive
positive :: Root -> Root
positive (Root r) = Root (positive' r)

--Own root generator used as [Ratio Int] Creates roots too low dim and
--  large in value (overflow problems)

-- Box value as a 1 element list
box :: a -> [a]
box a = [a]


-- Extend the given root by adding the given coefficient in the front
extend :: Ratio Int -> Root -> Root
extend w (Root r) = root (w:r)

instance Arbitrary Root where
  arbitrary = sized root'
      where root' 0 = single
            root' n = oneof [many,single]
            many = oneof $ map (\w->liftM (extend w) arbitrary) wieghts 
            single = oneof $ map (\w->liftM (extend w) empty) wieghts
            empty = return $ Root []
            wieghts = [a%b | a<-[-3..3], b<-[1..3]]

--Display a Ratio Int using / instead of % also displays a%1 as a
simple :: Ratio Int -> String
simple q
       | b==1 = show a
       | otherwise = show a ++ "/"++ show b
       where a = numerator q
             b = denominator q

instance Show Root where
    show (Root r) = "[" ++ (concat.intersperse"," $ map simple r) ++ "]"
